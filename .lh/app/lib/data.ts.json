{
    "sourceFile": "app/lib/data.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1714720478210,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1714720478210,
            "name": "Commit-0",
            "content": "import { sql } from '@vercel/postgres';\nimport {\n  CustomerField,\n  CustomersTableType,\n  InvoiceForm,\n  InvoicesTable,\n  LatestInvoiceRaw,\n  User,\n  Revenue,\n} from './definitions';\nimport { formatCurrency } from './utils';\n\nexport async function fetchRevenue() {\n  // Add noStore() here to prevent the response from being cached.\n  // This is equivalent to in fetch(..., {cache: 'no-store'}).\n\n  try {\n    // Artificially delay a response for demo purposes.\n    // Don't do this in production :)\n\n    // console.log('Fetching revenue data...');\n    // await new Promise((resolve) => setTimeout(resolve, 3000));\n\n    const data = await sql<Revenue>`SELECT * FROM revenue`;\n\n    // console.log('Data fetch completed after 3 seconds.');\n\n    return data.rows;\n  } catch (error) {\n    console.error('Database Error:', error);\n    throw new Error('Failed to fetch revenue data.');\n  }\n}\n\nexport async function fetchLatestInvoices() {\n  try {\n    const data = await sql<LatestInvoiceRaw>`\n      SELECT invoices.amount, customers.name, customers.image_url, customers.email, invoices.id\n      FROM invoices\n      JOIN customers ON invoices.customer_id = customers.id\n      ORDER BY invoices.date DESC\n      LIMIT 5`;\n\n    const latestInvoices = data.rows.map((invoice) => ({\n      ...invoice,\n      amount: formatCurrency(invoice.amount),\n    }));\n    return latestInvoices;\n  } catch (error) {\n    console.error('Database Error:', error);\n    throw new Error('Failed to fetch the latest invoices.');\n  }\n}\n\nexport async function fetchCardData() {\n  try {\n    // You can probably combine these into a single SQL query\n    // However, we are intentionally splitting them to demonstrate\n    // how to initialize multiple queries in parallel with JS.\n    const invoiceCountPromise = sql`SELECT COUNT(*) FROM invoices`;\n    const customerCountPromise = sql`SELECT COUNT(*) FROM customers`;\n    const invoiceStatusPromise = sql`SELECT\n         SUM(CASE WHEN status = 'paid' THEN amount ELSE 0 END) AS \"paid\",\n         SUM(CASE WHEN status = 'pending' THEN amount ELSE 0 END) AS \"pending\"\n         FROM invoices`;\n\n    const data = await Promise.all([\n      invoiceCountPromise,\n      customerCountPromise,\n      invoiceStatusPromise,\n    ]);\n\n    const numberOfInvoices = Number(data[0].rows[0].count ?? '0');\n    const numberOfCustomers = Number(data[1].rows[0].count ?? '0');\n    const totalPaidInvoices = formatCurrency(data[2].rows[0].paid ?? '0');\n    const totalPendingInvoices = formatCurrency(data[2].rows[0].pending ?? '0');\n\n    return {\n      numberOfCustomers,\n      numberOfInvoices,\n      totalPaidInvoices,\n      totalPendingInvoices,\n    };\n  } catch (error) {\n    console.error('Database Error:', error);\n    throw new Error('Failed to fetch card data.');\n  }\n}\n\nconst ITEMS_PER_PAGE = 6;\nexport async function fetchFilteredInvoices(\n  query: string,\n  currentPage: number,\n) {\n  const offset = (currentPage - 1) * ITEMS_PER_PAGE;\n\n  try {\n    const invoices = await sql<InvoicesTable>`\n      SELECT\n        invoices.id,\n        invoices.amount,\n        invoices.date,\n        invoices.status,\n        customers.name,\n        customers.email,\n        customers.image_url\n      FROM invoices\n      JOIN customers ON invoices.customer_id = customers.id\n      WHERE\n        customers.name ILIKE ${`%${query}%`} OR\n        customers.email ILIKE ${`%${query}%`} OR\n        invoices.amount::text ILIKE ${`%${query}%`} OR\n        invoices.date::text ILIKE ${`%${query}%`} OR\n        invoices.status ILIKE ${`%${query}%`}\n      ORDER BY invoices.date DESC\n      LIMIT ${ITEMS_PER_PAGE} OFFSET ${offset}\n    `;\n\n    return invoices.rows;\n  } catch (error) {\n    console.error('Database Error:', error);\n    throw new Error('Failed to fetch invoices.');\n  }\n}\n\nexport async function fetchInvoicesPages(query: string) {\n  try {\n    const count = await sql`SELECT COUNT(*)\n    FROM invoices\n    JOIN customers ON invoices.customer_id = customers.id\n    WHERE\n      customers.name ILIKE ${`%${query}%`} OR\n      customers.email ILIKE ${`%${query}%`} OR\n      invoices.amount::text ILIKE ${`%${query}%`} OR\n      invoices.date::text ILIKE ${`%${query}%`} OR\n      invoices.status ILIKE ${`%${query}%`}\n  `;\n\n    const totalPages = Math.ceil(Number(count.rows[0].count) / ITEMS_PER_PAGE);\n    return totalPages;\n  } catch (error) {\n    console.error('Database Error:', error);\n    throw new Error('Failed to fetch total number of invoices.');\n  }\n}\n\nexport async function fetchInvoiceById(id: string) {\n  try {\n    const data = await sql<InvoiceForm>`\n      SELECT\n        invoices.id,\n        invoices.customer_id,\n        invoices.amount,\n        invoices.status\n      FROM invoices\n      WHERE invoices.id = ${id};\n    `;\n\n    const invoice = data.rows.map((invoice) => ({\n      ...invoice,\n      // Convert amount from cents to dollars\n      amount: invoice.amount / 100,\n    }));\n\n    return invoice[0];\n  } catch (error) {\n    console.error('Database Error:', error);\n    throw new Error('Failed to fetch invoice.');\n  }\n}\n\nexport async function fetchCustomers() {\n  try {\n    const data = await sql<CustomerField>`\n      SELECT\n        id,\n        name\n      FROM customers\n      ORDER BY name ASC\n    `;\n\n    const customers = data.rows;\n    return customers;\n  } catch (err) {\n    console.error('Database Error:', err);\n    throw new Error('Failed to fetch all customers.');\n  }\n}\n\nexport async function fetchFilteredCustomers(query: string) {\n  try {\n    const data = await sql<CustomersTableType>`\n\t\tSELECT\n\t\t  customers.id,\n\t\t  customers.name,\n\t\t  customers.email,\n\t\t  customers.image_url,\n\t\t  COUNT(invoices.id) AS total_invoices,\n\t\t  SUM(CASE WHEN invoices.status = 'pending' THEN invoices.amount ELSE 0 END) AS total_pending,\n\t\t  SUM(CASE WHEN invoices.status = 'paid' THEN invoices.amount ELSE 0 END) AS total_paid\n\t\tFROM customers\n\t\tLEFT JOIN invoices ON customers.id = invoices.customer_id\n\t\tWHERE\n\t\t  customers.name ILIKE ${`%${query}%`} OR\n        customers.email ILIKE ${`%${query}%`}\n\t\tGROUP BY customers.id, customers.name, customers.email, customers.image_url\n\t\tORDER BY customers.name ASC\n\t  `;\n\n    const customers = data.rows.map((customer) => ({\n      ...customer,\n      total_pending: formatCurrency(customer.total_pending),\n      total_paid: formatCurrency(customer.total_paid),\n    }));\n\n    return customers;\n  } catch (err) {\n    console.error('Database Error:', err);\n    throw new Error('Failed to fetch customer table.');\n  }\n}\n\nexport async function getUser(email: string) {\n  try {\n    const user = await sql`SELECT * FROM users WHERE email=${email}`;\n    return user.rows[0] as User;\n  } catch (error) {\n    console.error('Failed to fetch user:', error);\n    throw new Error('Failed to fetch user.');\n  }\n}\n"
        }
    ]
}